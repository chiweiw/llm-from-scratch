# 合并流程提醒 copy.sql 性能分析与优化建议

## 1. 性能问题根源分析

经过对 SQL 代码的详细分析，执行耗时 600s 的主要原因在于 **高开销操作的重复执行**，具体如下：

### (1) 正则表达式关联 (REGEXP Join) 的放大效应
在 11 个流程分支的 `*_prd` CTE 中（例如 `sb_raw`, `prd_yz`, `suspend_prd` 等），每一处都执行了以下连接：
```sql
left join sys_rbac_user u on u.USER_O_CODE = ui.CREATE_USER
left join sys_rbac_depart d on u.ORG regexp d.DEPT_O_CODE
```
**问题**：`REGEXP` 操作无法利用索引，且计算开销极大。虽然单次执行可能尚可，但由于 `base_alerts` CTE 未被物化（Materialized），而后续的 `recipient_*` 逻辑多次引用了 `base_alerts`，导致这些底层的正则连接可能被重复计算了 **10次以上**。

### (2) `recipient_inv_sales_flow` 的多次扫描
在最新的修改中，为了修复投资/销售经理漏发问题，`recipient_inv_sales_flow` 被改写为 3 个 `UNION ALL` 的形式：
```sql
select ... from base_alerts ... join prd_roles ... where ... PM_MANAGER ...
UNION ALL
select ... from base_alerts ... join prd_roles ... where ... SECOND_MANAGER ...
UNION ALL
select ... from base_alerts ... join prd_roles ... where ... SALES_MANAGER ...
```
**问题**：这强制数据库对 `base_alerts` 进行 **3次全量扫描**。结合第 (1) 点，这意味着底层的正则连接和复杂逻辑被额外执行了 3 次。

### (3) `unfinished_instance` 的重复计算
`unfinished_instance` 包含了复杂的聚合查询（计算 `SCENE_CODE`），这个 CTE 被所有 11 个流程分支引用。如果数据库优化器没有智能地缓存该 CTE 结果，那么这个昂贵的聚合操作也会被重复执行。

---

## 2. 优化方案建议

为了显著降低执行时间，建议进行以下优化：

### 优化 1: 提取用户-部门映射 (User-Dept Map)
将昂贵的正则连接提取到一个独立的 CTE 中，仅对相关用户执行一次，然后在各个流程分支中直接关联该结果。

**优化前**: 在每个 `*_prd` 中写 `join sys_rbac_depart d on u.ORG regexp d.DEPT_O_CODE`
**优化后**:
```sql
-- 提取涉及到的所有创建人
active_creators as (
    select distinct CREATE_USER as USER_O_CODE from unfinished_instance
),
-- 一次性计算部门映射
creator_dept_map as (
    select 
        u.USER_O_CODE,
        d.DEPT_O_NAME
    from active_creators ac
    join sys_rbac_user u on u.USER_O_CODE = ac.USER_O_CODE
    join sys_rbac_depart d on u.ORG regexp d.DEPT_O_CODE
)
-- 后续在 *_prd 中直接 join creator_dept_map
```

### 优化 2: 重构 `recipient_inv_sales_flow`
将 3 次扫描合并为 1 次扫描，通过逻辑转换（Unpivot）来提取三个角色。

**优化代码示例**:
```sql
recipient_inv_sales_flow as (
    select
        case 
            when type.role = 'PM' then pr.PM_MANAGER
            when type.role = 'SECOND' then pr.SECOND_MANAGER
            when type.role = 'SALES' then pr.SALES_MANAGER
        end as account,
        ba.*
    from base_alerts ba
    join prd_roles pr on pr.PRD_CODE = ba.PRD_CODE
    cross join (
        select 'PM' as role union all select 'SECOND' union all select 'SALES'
    ) type
    where ba.SEND_INV_SALES = 1
      and (
          (type.role = 'PM' and pr.PM_MANAGER is not null) or
          (type.role = 'SECOND' and pr.SECOND_MANAGER is not null) or
          (type.role = 'SALES' and pr.SALES_MANAGER is not null)
      )
)
```

### 优化 3: 优化 `base_alerts` 引用
虽然无法强制 MySQL (5.7等老版本) 物化 CTE，但通过减少 `recipient_*` 中对 `base_alerts` 的引用次数（例如合并部分逻辑），或者通过上述优化1和2减轻 `base_alerts` 本身的计算负担，可以间接解决问题。

---

## 3. 预期效果
通过实施上述优化，特别是 **提取正则连接** 和 **合并表扫描**，预计执行时间可减少 **70% - 90%**，从 600s 降低到 60s 以内。
